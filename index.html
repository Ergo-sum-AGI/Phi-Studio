// --- Flake / Particle System integration ---

class Flake {
  constructor(position) {
    this.pos = position.clone();
    this.vel = new THREE.Vector3(
      (Math.random() - 0.5) * 0.3,
      (Math.random() - 0.5) * 0.3,
      (Math.random() - 0.5) * 0.3
    );
    this.hue = Math.random() * 360;
    this.life = 0;
    this.maxLife = 200 + Math.random() * 200;
    this.trail = []; // store last few positions
    this.trailLen = 12;
    for (let i = 0; i < this.trailLen; i++) {
      this.trail.push(this.pos.clone());
    }
  }

  update(dt) {
    // swirl force around Y-axis
    const swirl = new THREE.Vector3(-this.pos.z, 0, this.pos.x).normalize().multiplyScalar(0.04);
    // noise
    const noise = new THREE.Vector3(
      (Math.random() - 0.5) * 0.02,
      (Math.random() - 0.5) * 0.02,
      (Math.random() - 0.5) * 0.02
    );
    // attraction toward branch center lightly
    const attract = this.pos.clone().multiplyScalar(-0.0005);

    this.vel.add(swirl).add(noise).add(attract);
    this.vel.multiplyScalar(0.98);
    this.pos.add(this.vel.clone().multiplyScalar(dt));

    // update hue, life
    this.hue = (this.hue + 0.3) % 360;
    this.life++;

    // update trail
    this.trail.pop();
    this.trail.unshift(this.pos.clone());
  }

  isDead() {
    return this.life > this.maxLife;
  }
}

class FlakeSystem {
  constructor(maxCount = 500) {
    this.flakes = [];
    this.max = maxCount;

    // buffer geometry for flake heads
    this.geometry = new THREE.BufferGeometry();
    this.positions = new Float32Array(this.max * 3);
    this.colors = new Float32Array(this.max * 3);
    this.sizes = new Float32Array(this.max);
    this.geometry.setAttribute('position', new THREE.BufferAttribute(this.positions, 3));
    this.geometry.setAttribute('color', new THREE.BufferAttribute(this.colors, 3));
    this.geometry.setAttribute('size', new THREE.BufferAttribute(this.sizes, 1));

    // material
    this.material = new THREE.PointsMaterial({
      vertexColors: true,
      size: 1.8,
      transparent: true,
      opacity: 0.9,
      depthWrite: false,
      blending: THREE.AdditiveBlending
    });

    this.points = new THREE.Points(this.geometry, this.material);
    scene.add(this.points);

    // optionally, add trails as Lines (one per flake)
    this.trails = [];
  }

  spawn(pos) {
    if (this.flakes.length < this.max) {
      const f = new Flake(pos);
      this.flakes.push(f);
      // optionally create a Line for its trail
      const trailGeo = new THREE.BufferGeometry();
      const arr = new Float32Array(f.trailLen * 3);
      trailGeo.setAttribute('position', new THREE.BufferAttribute(arr, 3));
      const line = new THREE.Line(trailGeo,
        new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.4 })
      );
      line.userData.flake = f;
      scene.add(line);
      this.trails.push(line);
    }
  }

  update(dt) {
    let i = 0;
    for (let flake of this.flakes) {
      flake.update(dt);
      if (!flake.isDead()) {
        this.positions[3*i] = flake.pos.x;
        this.positions[3*i+1] = flake.pos.y;
        this.positions[3*i+2] = flake.pos.z;
        const c = new THREE.Color().setHSL((flake.hue / 360), 1, 0.6);
        this.colors[3*i] = c.r;
        this.colors[3*i+1] = c.g;
        this.colors[3*i+2] = c.b;
        this.sizes[i] = 2.0;
        // also update trail line if exists
        if (this.trails[i]) {
          const line = this.trails[i];
          const arr = line.geometry.attributes.position.array;
          for (let j = 0; j < flake.trailLen; j++) {
            const p = flake.trail[j];
            arr[3*j] = p.x; arr[3*j+1] = p.y; arr[3*j+2] = p.z;
          }
          line.geometry.attributes.position.needsUpdate = true;
          line.material.opacity = 0.2 * (1 - flake.life / flake.maxLife);
        }
        i++;
      }
    }
    // remove dead
    this.flakes = this.flakes.filter((f, idx) => {
      if (f.isDead()) {
        // also remove its trail
        if (this.trails[idx]) {
          scene.remove(this.trails[idx]);
        }
        return false;
      }
      return true;
    });
    // adjust geometry count
    this.geometry.setDrawRange(0, this.flakes.length);
    this.geometry.attributes.position.needsUpdate = true;
    this.geometry.attributes.color.needsUpdate = true;
    this.geometry.attributes.size.needsUpdate = true;
  }
}

const flakeSys = new FlakeSystem(600);

// In your animation loop, instead of just rigid snow, you do:
function animate() {
  requestAnimationFrame(animate);
  const dt = 0.016; // or based on time delta

  root.rotation.y += params.rotationSpeed * 0.6;

  // spawn from branch tips often
  tips.forEach((tip, idx) => {
    if (Math.random() < 0.05) {
      flakeSys.spawn(tip);
    }
  });

  flakeSys.update(dt);

  // existing traversal to color branches etc.
  scene.traverse(obj => {
    if (obj.isMesh) {
      // color or pulsing logic
    }
  });

  renderer.render(scene, camera);
}
