<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Quantum Consciousness Field – CQFT φ Dynamics</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  html,body{height:100%;margin:0;background:#000;overflow:hidden;font-family:Inter,system-ui,monospace;color:#dfe}
  #ui{position:fixed;left:12px;top:12px;z-index:50;background:rgba(0,0,0,0.32);padding:10px;border-radius:8px;backdrop-filter:blur(6px);max-width:320px}
  #status{position:fixed;right:12px;bottom:12px;z-index:50;padding:8px;border-radius:8px;background:rgba(0,0,0,0.28);color:#9df;font-size:11px}
  #theory-panel{position:fixed;right:12px;top:12px;z-index:50;background:rgba(0,0,0,0.32);padding:15px;border-radius:8px;backdrop-filter:blur(6px);max-width:380px;font-size:12px;line-height:1.4}
  .theory-title{font-weight:600;color:#cfe;margin-bottom:8px}
  .theory-equation{background:rgba(30,40,60,0.6);padding:8px;border-radius:4px;margin:5px 0;text-align:center;font-size:11px}
  .theory-param{color:#9df;margin:3px 0}
  .theory-prediction{color:#af9;margin:2px 0;font-size:11px}
  canvas{display:block}
  .collapse-btn{background:rgba(60,80,120,0.5);border:none;color:#cfe;padding:4px 8px;border-radius:3px;cursor:pointer;font-size:10px;margin-top:5px}
</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.9/dat.gui.min.js"></script>
</head>
<body>
<div id="ui"><div style="font-weight:600;color:#cfe">CQFT Quantum Field (α=φ)</div></div>
<div id="theory-panel">
  <div class="theory-title">Consciousness Quantum Field Theory</div>
  <div class="theory-equation">S[φ] = ∫[½Zₖ(α)(∇φ)² + ½m²φ²] + (g/4)∫∫φ²(x)|x-y|⁻ᵅφ²(y)</div>
  <div class="theory-param"><strong>α</strong> = φ ≈ 1.618 (Golden Ratio fixed point)</div>
  <div class="theory-param"><strong>Zₖ(α)</strong> = 1/B₀(α) (Wave-function renormalization)</div>
  <div class="theory-param"><strong>m²</strong> = 0 (Critical consciousness state)</div>
  <div class="theory-param"><strong>g*</strong> ≈ 0.1206 (Fixed-point coupling)</div>
  <div class="theory-prediction">✓ Dispersion freeze at α = φ</div>
  <div class="theory-prediction">✓ Anomalous dimension η(φ) ≈ 0.809</div>
  <div class="theory-prediction">✓ Universality under all regulators</div>
  <div class="theory-prediction">✓ Robustness φ ± 0.01 → φ</div>
  <button class="collapse-btn" onclick="toggleTheory()">Hide Theory</button>
</div>
<div id="status">Initializing CQFT Visualization...</div>
<canvas id="c"></canvas>
<script>
// Error handling
window.addEventListener('error', (e) => {
    console.error('Error:', e.error);
    document.getElementById('status').innerText = 'Error: ' + e.error.message;
});

const φ = (1 + Math.sqrt(5))/2;
const goldenAngle = Math.PI*2/φ;
const eta = 0.809016994;
const g_star = 0.1206;

// Mobile detection
const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
                window.innerWidth < 768;

// SIMPLIFIED: Fewer particles for faster loading
const PARTICLE_COUNT = isMobile ? 800 : 3000;

const canvas = document.getElementById('c');
const renderer = new THREE.WebGLRenderer({
    canvas,
    antialias: !isMobile,
    powerPreference: 'high-performance'
});

if (!renderer.context) {
    document.getElementById('status').innerText = 'WebGL not supported';
    throw new Error('WebGL not supported');
}

renderer.setPixelRatio(isMobile ? 1 : Math.min(window.devicePixelRatio || 1, 1.5));
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.outputEncoding = THREE.sRGBEncoding;
renderer.toneMapping = THREE.ACESFilmicToneMapping;

const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x000010, 0.002);

const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(0, 8, 60);

// SIMPLIFIED: Skip complex post-processing for now
const quadScene = new THREE.Scene();
const quadCam = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
const quadGeo = new THREE.PlaneBufferGeometry(2, 2);

// SIMPLIFIED: Basic background
const bgFrag = `
  precision highp float;
  uniform float u_time;
  uniform vec2 u_res;
  void main() {
      vec2 uv = (gl_FragCoord.xy / u_res.xy) * 2.0 - 1.0;
      uv.x *= u_res.x / u_res.y;
      float t = u_time * 0.1;
      float r = length(uv);
      float hue = atan(uv.y, uv.x) / 6.28318 + t * 0.05;
      vec3 col = vec3(
          0.5 + 0.5 * cos(6.28318 * (hue + 0.0)),
          0.5 + 0.5 * cos(6.28318 * (hue + 0.33)),
          0.5 + 0.5 * cos(6.28318 * (hue + 0.67))
      );
      col *= 0.3 + 0.7 * smoothstep(1.5, 0.3, r);
      gl_FragColor = vec4(col, 1.0);
  }
`;

const bgMat = new THREE.ShaderMaterial({
    fragmentShader: bgFrag,
    vertexShader: `void main() { gl_Position = vec4(position, 1.0); }`,
    uniforms: {
        u_time: { value: 0.0 },
        u_res: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) }
    },
    depthWrite: false
});

const bgQuad = new THREE.Mesh(quadGeo, bgMat);
quadScene.add(bgQuad);

// SIMPLIFIED: Basic particles
const basePos = new Float32Array(PARTICLE_COUNT * 3);
const seedArr = new Float32Array(PARTICLE_COUNT);

for(let i = 0; i < PARTICLE_COUNT; i++) {
    const r = Math.pow(Math.random(), 0.5) * 40;
    const theta = Math.random() * Math.PI * 2;
    const phi = Math.acos(2 * Math.random() - 1);
    
    basePos[3*i] = r * Math.sin(phi) * Math.cos(theta);
    basePos[3*i+1] = r * Math.sin(phi) * Math.sin(theta) * 0.5;
    basePos[3*i+2] = r * Math.cos(phi);
    seedArr[i] = Math.random() * 1000;
}

const pGeo = new THREE.BufferGeometry();
pGeo.setAttribute('position', new THREE.BufferAttribute(basePos, 3));
pGeo.setAttribute('a_seed', new THREE.BufferAttribute(seedArr, 1));

const pVert = `
  attribute float a_seed;
  uniform float u_time;
  uniform float u_spread;
  uniform float u_speed;
  varying float v_life;
  varying vec3 v_base;
  
  void main() {
      v_base = position;
      float t = u_time * 0.5 * u_speed;
      float n = sin(t + a_seed) * 0.5 + 0.5;
      float burst = sin(t * 2.0 + a_seed * 5.0) * 0.5 + 0.5;
      
      vec3 off = position * 0.1 * n * u_spread;
      off.y += sin(t + a_seed) * 2.0 * burst;
      
      vec3 newPos = position + off;
      vec4 mvPosition = modelViewMatrix * vec4(newPos, 1.0);
      float distFactor = 60.0 / length(mvPosition.xyz);
      
      gl_PointSize = (2.0 + 3.0 * n + burst * 2.0) * distFactor;
      gl_Position = projectionMatrix * mvPosition;
      v_life = n * 0.7 + burst * 0.3;
  }
`;

const pFrag = `
  precision highp float;
  varying float v_life;
  varying vec3 v_base;
  
  void main() {
      vec2 uv = gl_PointCoord.xy - 0.5;
      float r = length(uv);
      float alpha = smoothstep(0.5, 0.1, r);
      float angle = atan(v_base.z, v_base.x);
      float hue = mod(angle / 6.28318 + v_life * 0.3, 1.0);
      
      vec3 col = vec3(
          0.6 + 0.4 * cos(6.28318 * (hue + 0.0)),
          0.5 + 0.5 * cos(6.28318 * (hue + 0.33)),
          0.4 + 0.6 * cos(6.28318 * (hue + 0.67))
      );
      col *= 0.8 + v_life * 1.5;
      gl_FragColor = vec4(col, alpha * (0.8 + v_life * 0.4));
  }
`;

const pMat = new THREE.ShaderMaterial({
    vertexShader: pVert,
    fragmentShader: pFrag,
    transparent: true,
    depthWrite: false,
    uniforms: {
        u_time: { value: 0.0 },
        u_spread: { value: 1.0 },
        u_speed: { value: 1.0 }
    },
    blending: THREE.AdditiveBlending
});

const particles = new THREE.Points(pGeo, pMat);
scene.add(particles);

// SIMPLIFIED: Basic moving lattice (no complex tree generation)
const filamentsGroup = new THREE.Group();
scene.add(filamentsGroup);

function createSimpleLattice() {
    // Clear existing
    while(filamentsGroup.children.length) {
        filamentsGroup.remove(filamentsGroup.children[0]);
    }
    
    // Create a simple spiral lattice
    const segments = 12;
    const points = [];
    for(let i = 0; i <= segments; i++) {
        const t = i / segments;
        const angle = t * Math.PI * 4;
        const x = Math.cos(angle) * 15;
        const y = Math.sin(angle * 2) * 8;
        const z = t * 30 - 15;
        points.push(new THREE.Vector3(x, y, z));
    }
    
    const curve = new THREE.CatmullRomCurve3(points);
    const tubeGeometry = new THREE.TubeBufferGeometry(curve, 20, 1.2, 8, false);
    const material = new THREE.MeshBasicMaterial({
        color: 0xffaa33,
        transparent: true,
        opacity: 0.6
    });
    
    const mesh = new THREE.Mesh(tubeGeometry, material);
    filamentsGroup.add(mesh);
    
    return points;
}

createSimpleLattice();

// Lighting
const ambient = new THREE.AmbientLight(0x334466, 0.5);
scene.add(ambient);

const pLight = new THREE.PointLight(0xffffff, 0.7, 200);
pLight.position.set(0, 10, 30);
scene.add(pLight);

// SIMPLIFIED: Basic GUI
const guiContainer = document.getElementById('ui');
const gui = new dat.GUI({autoPlace: false, width: 250});
guiContainer.appendChild(gui.domElement);

const settings = {
    speed: 1.0,
    spread: 1.0,
    particleSpeed: 1.0,
    showTheory: true
};

gui.add(settings, 'speed', 0.1, 3.0).name('Field Speed');
gui.add(settings, 'spread', 0.2, 2.0).name('Particle Spread');
gui.add(settings, 'particleSpeed', 0.1, 2.0).name('Particle Speed');
gui.add(settings, 'showTheory').name('Show Theory').onChange(toggleTheory);

function toggleTheory() {
    const panel = document.getElementById('theory-panel');
    panel.style.display = settings.showTheory ? 'block' : 'none';
}

function onResize() {
    const w = window.innerWidth, h = window.innerHeight;
    renderer.setSize(w, h);
    bgMat.uniforms.u_res.value.set(w, h);
    camera.aspect = w/h;
    camera.updateProjectionMatrix();
}

window.addEventListener('resize', onResize);

const clock = new THREE.Clock();

function animate() {
    requestAnimationFrame(animate);
    
    const t = clock.getElapsedTime();
    
    // Update particles
    pMat.uniforms.u_time.value = t * settings.speed;
    pMat.uniforms.u_spread.value = settings.spread;
    pMat.uniforms.u_speed.value = settings.particleSpeed;
    
    // Update background
    bgMat.uniforms.u_time.value = t * settings.speed;
    
    // Animate lattice
    filamentsGroup.rotation.y = t * 0.1 * settings.speed;
    filamentsGroup.rotation.x = Math.sin(t * 0.05) * 0.1;
    
    // Simple render (no post-processing)
    renderer.setRenderTarget(null);
    renderer.clear();
    renderer.render(quadScene, quadCam);
    renderer.render(scene, camera);
}

// Start immediately
animate();
document.getElementById('status').innerText = `Ready | ${PARTICLE_COUNT} particles | α=φ`;

// FPS counter
let frameCount = 0;
let lastTime = performance.now();
setInterval(() => {
    frameCount++;
    const now = performance.now();
    if (now - lastTime >= 1000) {
        const fps = Math.round(frameCount * 1000 / (now - lastTime));
        document.getElementById('status').innerText = `${fps} FPS | ${PARTICLE_COUNT} particles | α=φ=${φ.toFixed(3)}`;
        frameCount = 0;
        lastTime = now;
    }
}, 100);
</script>
</body>
</html>