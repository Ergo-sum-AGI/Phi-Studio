const bgFrag = `
  precision highp float;
  uniform float u_time;
  uniform vec2 u_res;
  ${glslCommon}
  
  #define PHI 1.618034
  #define ETA 0.809017
  
  vec2 rotate(vec2 p, float a) {
    float c = cos(a), s = sin(a);
    return vec2(c*p.x - s*p.y, s*p.x + c*p.y);
  }
  
  float quantumField(vec2 p, float t) {
    float field = 0.0;
    float angle = atan(p.y, p.x);
    float radius = length(p);
    
    // φ-symmetric angular modes
    for(int i = 0; i < 5; i++) {
      float fi = float(i);
      float phaseAngle = angle * PHI * (1.0 + fi*0.5) + t * (0.3 + fi*0.1);
      float radialWave = sin(radius * (2.0 + fi*PHI) - t * (0.8 + fi*0.2)) * 0.5 + 0.5;
      field += cos(phaseAngle * (3.0 + fi)) * radialWave * exp(-fi*0.3);
    }
    
    return field / 5.0;
  }
  
  void main(){
    vec2 uv = (gl_FragCoord.xy / u_res.xy) * 2.0 - 1.0;
    uv.x *= u_res.x/u_res.y;
    float t = u_time * 0.15;
    
    // Multi-scale swirling fields
    vec2 p1 = rotate(uv * 0.8, t * 0.2);
    vec2 p2 = rotate(uv * 1.5, -t * 0.3 + PHI);
    vec2 p3 = rotate(uv * 2.5, t * 0.4 + ETA);
    
    float q1 = quantumField(p1, t);
    float q2 = quantumField(p2, t * PHI);
    float q3 = quantumField(p3, t * ETA);
    
    // Interference patterns (quantum superposition)
    float interference = (q1 + q2*0.7 + q3*0.5) / 2.2;
    
    // Dispersion waves (ω(k,α) relation)
    float radius = length(uv);
    float dispersion = 0.0;
    for(int i=0; i<3; i++) {
      float fi = float(i) + 1.0;
      dispersion += sin(radius * fi * PHI - t * 0.6 / pow(fi, ETA)) * exp(-fi*0.4);
    }
    dispersion = dispersion * 0.5 + 0.5;
    
    // Field fluctuations
    vec2 flowUV = uv + vec2(
      sin(uv.y * 3.0 + t) * 0.15,
      cos(uv.x * 3.0 - t) * 0.15
    );
    float turbulence = fbm(flowUV * 4.0 + t * 0.3);
    
    // Combine fields
    float field = interference * 0.6 + dispersion * 0.3 + turbulence * 0.1;
    field = smoothstep(0.15, 0.95, field);
    
    // Kaleidoscopic color (φ-based hue cycling)
    float angle = atan(uv.y, uv.x) / 3.14159;
    float hue = mod(angle * PHI + field * 0.4 + t * 0.08, 1.0);
    
    // Multi-frequency color oscillations
    vec3 col = vec3(
      0.5 + 0.5 * cos(6.28318 * (hue + 0.0)),
      0.5 + 0.5 * cos(6.28318 * (hue + 0.33)),
      0.5 + 0.5 * cos(6.28318 * (hue + 0.66))
    );
    
    // Brightness modulation (simulate field intensity)
    col *= 0.4 + 1.8 * field;
    
    // Radial pulses (firework-like bursts)
    float pulse = sin(radius * 8.0 - t * 2.0) * 0.5 + 0.5;
    col += vec3(pulse * 0.3) * field;
    
    // Vignette
    float vign = smoothstep(2.0, 0.6, radius);
    col *= 0.7 + 0.3 * vign;
    
    gl_FragColor = vec4(col, 1.0);
  }
`;