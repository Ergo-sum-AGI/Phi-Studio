<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Fractal Consciousness — Luminous Field Edition</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  html,body{height:100%;margin:0;background:#000;overflow:hidden;font-family:Inter,system-ui,monospace;color:#dfe}
  #ui{position:fixed;left:12px;top:12px;z-index:50;background:rgba(0,0,0,0.32);padding:10px;border-radius:8px;backdrop-filter:blur(6px)}
  #status{position:fixed;right:12px;bottom:12px;z-index:50;padding:8px;border-radius:8px;background:rgba(0,0,0,0.28);color:#9df}
  canvas{display:block}
  .small{font-size:12px;color:#bcd}
</style>

<!-- three + dat.gui via cdnjs (r128 compatible UMD) -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.9/dat.gui.min.js"></script>
</head>
<body>
<div id="ui"><div style="font-weight:600;color:#cfe">Fractal Consciousness — Controls</div></div>
<div id="status">Status: initializing…</div>
<canvas id="c"></canvas>

<script>
/* ======================
   Configurable constants
   ====================== */
const PARTICLE_COUNT = 16000; // lower if slow (4000,8000,16000)
const BASE_WIDTH = window.innerWidth;
const BASE_HEIGHT = window.innerHeight;

/* ======================
   Renderer / Scene / Camera
   ====================== */
const canvas = document.getElementById('c');
const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
renderer.setSize(BASE_WIDTH, BASE_HEIGHT);
renderer.outputEncoding = THREE.sRGBEncoding;

const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x000010, 0.0025);

const camera = new THREE.PerspectiveCamera(60, BASE_WIDTH/BASE_HEIGHT, 0.1, 1000);
camera.position.set(0, 10, 110);
scene.add(camera);

/* ----------------------
   Render targets for bloom pipeline
   ---------------------- */
function makeRT(w, h) {
  return new THREE.WebGLRenderTarget(w, h, {
    minFilter: THREE.LinearFilter,
    magFilter: THREE.LinearFilter,
    format: THREE.RGBAFormat,
    encoding: THREE.sRGBEncoding
  });
}
let rtScene = makeRT(BASE_WIDTH, BASE_HEIGHT);
let rtBright = makeRT(Math.floor(BASE_WIDTH/2), Math.floor(BASE_HEIGHT/2));
let rtBlurA = makeRT(Math.floor(BASE_WIDTH/4), Math.floor(BASE_HEIGHT/4));
let rtBlurB = makeRT(Math.floor(BASE_WIDTH/4), Math.floor(BASE_HEIGHT/4));

/* Orthographic camera & quad for fullscreen passes */
const quadScene = new THREE.Scene();
const quadCam = new THREE.OrthographicCamera(-1,1,1,-1,0,1);
const quadGeo = new THREE.PlaneBufferGeometry(2,2);

/* ======================
   Utility shaders (fbm, noise)
   ====================== */
// Common GLSL: hash, noise, fbm (2D)
const glslCommon = `
  // IQ-style hash / noise
  float hash21(vec2 p){p = fract(p*vec2(123.34,456.21)); p += dot(p,p+45.32); return fract(p.x*p.y);}
  float noise(vec2 p){
    vec2 i=floor(p); vec2 f=fract(p);
    float a=hash21(i), b=hash21(i+vec2(1.,0.)), c=hash21(i+vec2(0.,1.)), d=hash21(i+vec2(1.,1.));
    vec2 u=f*f*(3.0-2.0*f);
    return mix(a,b,u.x) + (c - a)*u.y*(1.0-u.x) + (d - b)*u.x*u.y;
  }
  float fbm(vec2 x) {
    float v=0.0; float a=0.5;
    for(int i=0;i<6;i++){ v += a*noise(x); x *= 2.0; a *= 0.5; }
    return v;
  }
`;

/* ======================
   Fractal background shader (fullscreen quad)
   ====================== */
const bgFrag = `
  precision highp float;
  uniform float u_time;
  uniform vec2 u_res;
  ${glslCommon}
  void main(){
    vec2 uv = (gl_FragCoord.xy / u_res.xy) * 2.0 - 1.0;
    uv.x *= u_res.x/u_res.y;
    vec2 p = uv * 1.8;
    float t = u_time * 0.08;

    // layered fbm with golden ratio scaling
    float f = fbm(p * 1.0 + vec2(t, t*0.6));
    float g = fbm(p * 2.2 + vec2(-t*0.7, t*0.5));
    float m = smoothstep(0.14, 0.8, f * (0.7 + 0.6*g));

    // golden-harmonic coloring
    float phi = 1.61803398875;
    float hue = mod((atan(uv.y,uv.x)/3.14159 + 0.5) + f*0.3 + t*0.03, 1.0);
    vec3 col = vec3(0.5 + 0.5*cos(6.28318*(vec3(hue, hue+0.33, hue+0.66))));
    col *= mix(0.35, 1.6, m);
    // subtle vignetting and fog
    float vign = smoothstep(1.6, 0.5, length(uv));
    col *= 1.0 - 0.4 * vign;
    gl_FragColor = vec4(col, clamp(m, 0.0, 1.0));
  }
`;
const bgMat = new THREE.ShaderMaterial({
  fragmentShader: bgFrag,
  vertexShader: `void main(){ gl_Position = vec4(position,1.0); }`,
  uniforms: {
    u_time: { value: 0.0 },
    u_res: { value: new THREE.Vector2(BASE_WIDTH, BASE_HEIGHT) }
  },
  depthWrite: false
});
const bgQuad = new THREE.Mesh(quadGeo, bgMat);
quadScene.add(bgQuad);

/* ======================
   Particle system: GPU-driven points (vertex displaces with fbm)
   ====================== */
const PARTICLE = {
  count: PARTICLE_COUNT,
  spread: 60
};

// create base positions attribute (random spread around spiral region)
const basePos = new Float32Array(PARTICLE.count * 3);
for (let i=0;i<PARTICLE.count;i++){
  const a = Math.random() * Math.PI * 2;
  const r = Math.pow(Math.random(), 0.7) * (10 + Math.random()*38);
  const x = Math.cos(a) * r * (0.2 + Math.random()*0.9);
  const y = (Math.random()-0.2) * 18;
  const z = Math.sin(a) * r * (0.2 + Math.random()*0.9);
  basePos[3*i] = x;
  basePos[3*i+1] = y;
  basePos[3*i+2] = z;
}
const pGeo = new THREE.BufferGeometry();
pGeo.setAttribute('position', new THREE.BufferAttribute(basePos, 3));
pGeo.setAttribute('a_seed', new THREE.BufferAttribute(new Float32Array(Array.from({length:PARTICLE.count}, (_,i)=>Math.random()*1000)), 1));

/* Particle shader (vertex computes animated position with fbm-based displacement) */
const pVert = `
  precision highp float;
  attribute vec3 position;
  attribute float a_seed;
  uniform float u_time;
  uniform float u_spread;
  uniform float u_speed;
  varying float v_life;
  varying vec3 v_base;
  ${glslCommon}

  // 2D curl-ish pseudo-force via fbm derivatives
  vec2 curl2(vec2 p) {
    float e = 0.001;
    float n1 = fbm(p + vec2(e, 0.0));
    float n2 = fbm(p + vec2(-e, 0.0));
    float n3 = fbm(p + vec2(0.0, e));
    float n4 = fbm(p + vec2(0.0, -e));
    return vec2(n3 - n4, n2 - n1) / (2.0 * e);
  }

  void main(){
    v_base = position;
    // work in 2D field (x,z) for swirling
    vec2 pXZ = position.xz * 0.03 + u_time * 0.02 * u_*
